<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LLM Semantris Tower</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            inter: ["Inter", "sans-serif"],
          },
          colors: {
            tealsoft: "#4fd1c5", 
          },
          keyframes: {
            dropIn: {
              "0%": { transform: "translateY(-40px)", opacity: "0" },
              "100%": { transform: "translateY(0)", opacity: "1" },
            },
            // NEW: More dynamic "pop out" for annihilation
            popOut: {
              "0%": { transform: "scale(1)", opacity: "1" },
              "100%": { transform: "scale(0.5) rotate(15deg)", opacity: "0" },
            }
          },
          animation: {
            dropIn: "dropIn 0.75s ease-out",
            popOut: "popOut 0.5s ease-in"
          },
        },
      },
    };
  </script>

  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap"
  />

  <style>
    body {
      background: #0d0d0d;
      overflow: hidden;
    }

    .word-item {
      /*
        Transitions are now handled by JavaScript (FLIP)
        for re-ordering, but we keep 'color' for highlighting.
      */
      transition: color 0.3s ease;
      text-align: center;
      padding: 0.3rem 1rem;
    }
    
    .removing {
      /* Uses the new 'popOut' keyframe */
      animation: popOut 0.5s ease-in forwards;
      /* Ensure removed words go "behind" others while animating */
      z-index: 0; 
    }

    .hit-zone-gradient {
      background: linear-gradient(
        to top,
        rgba(79, 209, 197, 0.25), 
        rgba(79, 209, 197, 0.10),
        transparent
      );
      pointer-events: none;
      
      /* FIX: Added the "Annihilation Line"
        This adds a dashed line at the top of the 4-word hit zone.
      */
      border-top: 2px dashed rgba(79, 209, 197, 0.4);
    }

    #tower-wrapper::-webkit-scrollbar {
      width: 4px;
    }
    #tower-wrapper::-webkit-scrollbar-thumb {
      background: #4a5568; 
      border-radius: 4px;
    }
  </style>
</head>

<body class="font-inter text-slate-400">
  
  <div class="w-full max-w-md mx-auto flex flex-col h-screen px-4 py-6">

    <div class="flex items-center justify-between mb-6">
      <div>
        <div class="text-xs tracking-widest text-gray-500">SCORE</div>
        <div id="score-display" class="text-4xl font-bold text-white">{{ score }}</div>
      </div>
      <div class="text-center">
        <div class="text-xs tracking-widest text-gray-500">TIME</div>
        <div id="timer-display" class="text-3xl font-semibold text-white">00:00</div>
      </div>
      <div class="text-right">
        <div class="text-xs tracking-widest text-gray-500">TARGET</div>
        <div
          id="target-word-display"
          class="text-2xl font-bold text-tealsoft"
        >
          {{ target_word }}
        </div>
      </div>
    </div>

    <div class="relative flex-grow overflow-hidden my-4">
      
      <div
        class="hit-zone-gradient absolute bottom-0 left-0 w-full h-48"
      ></div>

      <div id="tower-wrapper" class="h-full w-full overflow-y-auto absolute bottom-0 left-0">
        <div
          id="tower"
          class="flex flex-col-reverse h-full px-4 py-4 space-y-2 space-y-reverse"
        >
          {% for word in game_board %}
          <div
            data-word="{{ word }}"
            class="word-item text-lg font-semibold tracking-wide {% if word == target_word %}text-tealsoft font-bold{% else %}text-slate-400{% endif %}"
            style="order: {{ loop.index0 }}"
          >
            {{ word }}
          </div>
          {% endfor %}
        </div>
      </div>
    </div>

    <div
      class="mt-auto rounded-2xl bg-slate-900 border border-slate-700 shadow-xl px-4 py-4"
    >
      <form id="clue-form">
        <input
          type="text"
          id="clue-input"
          class="w-full px-4 py-3 rounded-xl bg-slate-800 text-white text-lg border border-slate-600 focus:outline-none focus:ring-2 focus:ring-tealsoft placeholder-slate-400"
          placeholder="Type a clue and press Enter..."
          autocomplete="off"
        />
        <button
          id="submit-button"
          type="submit"
          class="w-full mt-3 px-4 py-3 rounded-xl bg-tealsoft/90 hover:bg-tealsoft text-black font-semibold text-lg transition-all disabled:opacity-60 disabled:cursor-not-allowed"
        >
          Submit Clue
        </button>
      </form>
      <div
        id="message-area"
        class="h-6 mt-3 text-center text-sm text-slate-400"
      ></div>
    </div>
  </div>

  <script>
    // --- START: Variable declarations (No change) ---
    const tower = document.getElementById("tower");
    const form = document.getElementById("clue-form");
    const input = document.getElementById("clue-input");
    const submitButton = document.getElementById("submit-button");
    const message = document.getElementById("message-area");
    const scoreDisplay = document.getElementById("score-display");
    const targetDisplay = document.getElementById("target-word-display");
    const timerDisplay = document.getElementById("timer-display");

    let animating = false;

    // --- Timer (No change) ---
    const startTime = Date.now();
    setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const m = String(Math.floor(elapsed / 60)).padStart(2, "0");
      const s = String(elapsed % 60).padStart(2, "0");
      timerDisplay.textContent = `${m}:${s}`;
    }, 1000);
    // --- END: Variable declarations (No change) ---


    // --- Form submit handler ---
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      if (animating) return;

      const clue = input.value.trim();
      if (!clue) return;

      setLoading(true);

      try {
        const res = await fetch("/rank", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ clue }),
        });

        const result = await res.json();
        setLoading(false);
        input.value = "";

        if (result.error) {
          showMessage(result.error, "error");
          return;
        }

        animating = true;
        
        // --- ANIMATION LOGIC ---
        if (result.hit) {
          showMessage(`Hit! Removed ${result.words_removed.length} word(s).`, "hit");
          animateHitAndRedraw(result);
        } else {
          showMessage("Miss! Tower reordered.", "miss");
          // FIX: Call the new updateTower function for smooth reordering
          // No timeout needed for a miss
          updateTower(result.new_board, result.new_target, result.new_score, false);
          animating = false; // Re-enable input after animation
        }
        
      } catch (err) {
        setLoading(false);
        showMessage("Network error. Please try again.", "error");
      }
    });

    // --- Helper functions (No change) ---
    function setLoading(isLoading) {
      submitButton.disabled = isLoading;
      submitButton.textContent = isLoading ? "Thinking..." : "Submit Clue";
      if (isLoading) showMessage(""); 
    }

    function showMessage(msg, type = "info") {
      message.textContent = msg;
      let classes = "h-6 mt-3 text-center text-sm ";
      if (type === "error") classes += "text-red-400";
      else if (type === "hit") classes += "text-tealsoft";
      else if (type === "miss") classes += "text-yellow-400";
      else classes += "text-slate-400";
      message.className = classes;
    }
    
    
    // --- START: REWRITTEN ANIMATION FUNCTIONS ---

    /**
     * This function is now DEPRECATED.
     * Its logic is merged into the new `updateTower` function.
     */
    function applyRankedOrder(rankedList) {
      // No-op. Use updateTower(rankedList, ...)
    }

    /**
     * This function now *only* handles the "pop out" animation
     * and schedules the tower update.
     */
    function animateHitAndRedraw(result) {
      const wordsToRemove = new Set(result.words_removed);
      
      // 1. Mark words for removal
      tower.querySelectorAll(".word-item").forEach(el => {
        if (wordsToRemove.has(el.dataset.word)) {
          el.classList.add("removing");
        }
      });

      // 2. Wait for the "popOut" (0.5s) animation to finish
      setTimeout(() => {
        // 3. Update the tower. This will handle falling AND spawning.
        updateTower(result.new_board, result.new_target, result.new_score, true);
        animating = false; // Re-enable input
      }, 500); // Must match 'popOut' animation duration
    }

    /**
     * This function is DEPRECATED.
     * Its logic is merged into the new `updateTower` function.
     */
    function rebuildTower(wordList, newTarget, newScore) {
      // No-op. Use updateTower(wordList, newTarget, newScore, ...)
    }


    /**
     * NEW: The master function for all tower updates.
     * This handles smooth re-ordering, falling, and spawning
     * using the FLIP animation technique.
     *
     * @param {string[]} wordList - The new list of words for the board.
     * @param {string} newTarget - The new target word.
     * @param {number} newScore - The new score.
     * @param {boolean} isHit - True if this update is from a hit (handles removed words).
     */
    function updateTower(wordList, newTarget, newScore, isHit) {
      
      // --- FLIP: First ---
      // 1. Get the current positions of all *valid* words
      const existingElements = new Map();
      const firstPositions = new Map();
      
      const query = isHit ? ".word-item:not(.removing)" : ".word-item";
      tower.querySelectorAll(query).forEach(el => {
        const word = el.dataset.word;
        existingElements.set(word, el);
        firstPositions.set(word, el.getBoundingClientRect());
      });
      
      // --- Update DOM (Hidden "Last" state) ---
      // 2. Clear the tower and rebuild it in the *new* order.
      //    We do this to easily add/remove/reorder elements.
      tower.innerHTML = "";
      const newTargetLower = newTarget.toLowerCase();
      const elementsToAnimate = [];

      wordList.forEach((word, idx) => {
        const el = document.createElement("div");
        el.dataset.word = word;
        el.textContent = word;
        el.style.order = idx; // Set the *new* final order (0=bottom)
        el.className = "word-item text-lg font-semibold tracking-wide"; // Base class

        // 3. Check if this word is new or existing
        if (existingElements.has(word)) {
          // It's an existing word. It needs to "fall" or "move".
          // We will animate it with FLIP.
          const firstPos = firstPositions.get(word);
          elementsToAnimate.push({ el, firstPos });
        } else {
          // It's a brand new word. It needs to "drop in".
          el.classList.add("animate-dropIn");
        }
        
        // 4. Set final styles (colors)
        if (word.toLowerCase() === newTargetLower) {
          el.classList.add("text-tealsoft", "font-bold");
        } else if (idx < 4) {
          el.classList.add("text-slate-100"); // Hit zone
        } else {
          el.classList.add("text-slate-400"); // Default
        }
        
        tower.appendChild(el);
      });

      // --- FLIP: Invert & Play ---
      // 5. Animate all the existing words from their "First"
      //    position to their "Last" position.
      elementsToAnimate.forEach(({ el, firstPos }) => {
        const lastPos = el.getBoundingClientRect();
        
        // Calculate the difference
        const deltaY = firstPos.top - lastPos.top;
        
        // Only animate if it actually moved
        if (Math.abs(deltaY) > 1) {
          // INVERT: Move it back to its old position
          el.style.transition = 'none';
          el.style.transform = `translateY(${deltaY}px)`;
          
          // Force browser repaint
          el.offsetHeight; 
          
          // PLAY: Animate it back to its new position (transform: 0)
          el.style.transition = 'transform 0.5s ease';
          el.style.transform = 'translateY(0px)';
          
          // Clean up after
          el.addEventListener('transitionend', () => {
            el.style.transition = '';
            el.style.transform = '';
          }, { once: true });
        }
      });
      
      // 6. Update score and target displays
      scoreDisplay.textContent = newScore;
      targetDisplay.textContent = newTarget;
    }
    
    // --- END: REWRITTEN ANIMATION FUNCTIONS ---

  </script>
</body>
</html>