<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LLM Semantris Tower (Canvas)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            inter: ["Inter", "sans-serif"],
          },
          colors: {
            tealsoft: "#4fd1c5",
          },
        },
      },
    };
  </script>

  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap"
  />

  <style>
    body {
      background: #0d0d0d;
      overflow: hidden;
    }
    /* We keep the scrollbar simple for now, as the canvas won't scroll */
    ::-webkit-scrollbar {
      width: 4px;
    }
    ::-webkit-scrollbar-thumb {
      background: #4a5568;
      border-radius: 4px;
    }
  </style>
</head>

<body
  class="font-inter text-slate-400"
  data-initial-board="{{ game_board | join(',') }}"
  data-initial-target="{{ target_word }}"
  data-initial-score="{{ score }}"
>
  <div class="w-full max-w-md mx-auto flex flex-col h-screen px-4 py-6">
    <div class="flex items-center justify-between mb-6">
      <div>
        <div class="text-xs tracking-widest text-gray-500">SCORE</div>
        <div id="score-display" class="text-4xl font-bold text-white">
          {{ score }}
        </div>
      </div>
      <div class="text-center">
        <div class="text-xs tracking-widest text-gray-500">TIME</div>
        <div id="timer-display" class="text-3xl font-semibold text-white">
          00:00
        </div>
      </div>
      <div class="text-right">
        <div class="text-xs tracking-widest text-gray-500">TARGET</div>
        <div
          id="target-word-display"
          class="text-2xl font-bold text-tealsoft"
        >
          {{ target_word }}
        </div>
      </div>
    </div>

    <div class="relative flex-grow overflow-hidden my-4 border border-slate-700 rounded-lg">
      <canvas id="game-canvas" class="w-full h-full"></canvas>
    </div>

    <div
      class="mt-auto rounded-2xl bg-slate-900 border border-slate-700 shadow-xl px-4 py-4"
    >
      <form id="clue-form">
        <input
          type="text"
          id="clue-input"
          class="w-full px-4 py-3 rounded-xl bg-slate-800 text-white text-lg border border-slate-600 focus:outline-none focus:ring-2 focus:ring-tealsoft placeholder-slate-400"
          placeholder="Type a clue and press Enter..."
          autocomplete="off"
        />
        <button
          id="submit-button"
          type="submit"
          class="w-full mt-3 px-4 py-3 rounded-xl bg-tealsoft/90 hover:bg-tealsoft text-black font-semibold text-lg transition-all disabled:opacity-60 disabled:cursor-not-allowed"
        >
          Submit Clue
        </button>
      </form>
      <div
        id="message-area"
        class="h-6 mt-3 text-center text-sm text-slate-400"
      ></div>
    </div>
  </div>

  <script>
    // --- 1. Get DOM Elements ---
    const form = document.getElementById("clue-form");
    const input = document.getElementById("clue-input");
    const submitButton = document.getElementById("submit-button");
    const message = document.getElementById("message-area");
    const scoreDisplay = document.getElementById("score-display");
    const targetDisplay = document.getElementById("target-word-display");
    const timerDisplay = document.getElementById("timer-display");

    // --- 2. Canvas Setup ---
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");

    // --- 3. Game State ---
    // This object will hold *everything* about our game
    const gameState = {
      board: [],
      targetWord: "",
      score: 0,
      animating: false,
    };

    // --- 4. Game Constants ---
    const WORD_HEIGHT = 36; // Height of each word line in pixels
    const HIT_ZONE_WORDS = 4;
    const HIT_ZONE_HEIGHT = WORD_HEIGHT * HIT_ZONE_WORDS;
    const ANNIHILATION_LINE_Y = HIT_ZONE_HEIGHT + 2; // Y-position from bottom

    // --- 5. Helper Functions (Form/Message) ---
    // These are mostly unchanged
    function setLoading(isLoading) {
      gameState.animating = isLoading; // Use global state
      submitButton.disabled = isLoading;
      submitButton.textContent = isLoading ? "Thinking..." : "Submit Clue";
      if (isLoading) showMessage("");
    }

    function showMessage(msg, type = "info") {
      message.textContent = msg;
      let classes = "h-6 mt-3 text-center text-sm ";
      if (type === "error") classes += "text-red-400";
      else if (type === "hit") classes += "text-tealsoft";
      else if (type === "miss") classes += "text-yellow-400";
      else classes += "text-slate-400";
      message.className = classes;
    }

    // --- 6. Form Submit Handler (Logic is modified) ---
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      if (gameState.animating) return;

      const clue = input.value.trim();
      if (!clue) return;

      setLoading(true);

      try {
        const res = await fetch("/rank", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ clue }),
        });

        const result = await res.json();
        setLoading(false);
        input.value = "";

        if (result.error) {
          showMessage(result.error, "error");
          return;
        }

        // --- NEW CANVAS LOGIC ---
        // Instead of complex DOM animations, we just update the
        // game state. The `draw()` function will handle the rest.
        // We also update the HTML UI displays.
        
        gameState.board = result.new_board;
        gameState.targetWord = result.new_target;
        gameState.score = result.new_score;

        scoreDisplay.textContent = result.new_score;
        targetDisplay.textContent = result.new_target;
        
        if (result.hit) {
          showMessage(`Hit! Removed ${result.words_removed.length} word(s).`, "hit");
          // NOTE: We are NOT animating yet. The words will
          // just instantly update. Animation is the next complex step.
        } else {
          showMessage("Miss! Tower reordered.", "miss");
        }
        
      } catch (err) {
        setLoading(false);
        showMessage("Network error. Please try again.", "error");
      }
    });

    // --- 7. The Render Loop ---
    
    /**
     * Resizes the canvas to match its display size.
     * This is crucial for crisp text and graphics.
     */
    function resizeCanvas() {
      const { width, height } = canvas.getBoundingClientRect();
      canvas.width = width * window.devicePixelRatio;
      canvas.height = height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      return { width, height };
    }
    
    /**
     * The main draw function. This is called ~60 times per second.
     */
    function draw() {
      // Get the *CSS* dimensions of the canvas
      const { width, height } = resizeCanvas();
      
      // Clear the canvas
      ctx.clearRect(0, 0, width, height);
      
      // --- Draw Hit Zone Gradient ---
      const gradient = ctx.createLinearGradient(0, height, 0, height - HIT_ZONE_HEIGHT);
      gradient.addColorStop(0, "rgba(79, 209, 197, 0.20)");
      gradient.addColorStop(0.5, "rgba(79, 209, 197, 0.10)");
      gradient.addColorStop(1, "transparent");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, height - HIT_ZONE_HEIGHT, width, HIT_ZONE_HEIGHT);
      
      // --- Draw Annihilation Line ---
      ctx.save(); // Save current state
      ctx.strokeStyle = "rgba(79, 209, 197, 0.4)";
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      const lineY = Math.floor(height - ANNIHILATION_LINE_Y);
      ctx.moveTo(0, lineY);
      ctx.lineTo(width, lineY);
      ctx.stroke();
      ctx.restore(); // Restore to solid line

      // --- Draw Words ---
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const centerX = width / 2;

      gameState.board.forEach((word, index) => {
        // Calculate Y position (from the bottom up)
        const y = height - (index * WORD_HEIGHT) - (WORD_HEIGHT / 2);

        // Stop drawing words that are off-screen
        if (y < -WORD_HEIGHT) {
          return;
        }

        // Set styles
        if (word.toLowerCase() === gameState.targetWord.toLowerCase()) {
          ctx.font = "bold 1.125rem Inter, sans-serif"; // 18px
          ctx.fillStyle = "#4fd1c5"; // tealsoft
        } else if (index < HIT_ZONE_WORDS) {
          ctx.font = "600 1.125rem Inter, sans-serif";
          ctx.fillStyle = "#f1f5f9"; // slate-100
        } else {
          ctx.font = "600 1.125rem Inter, sans-serif";
          ctx.fillStyle = "#94a3b8"; // slate-400
        }
        
        ctx.fillText(word, centerX, y);
      });
    }

    /**
     * The main game loop.
     */
    function gameLoop() {
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    /**
     * Initializes the game.
     */
    function init() {
      // Read initial data from the <body> tag
      const body = document.body;
      const initialBoardStr = body.dataset.initialBoard;
      gameState.board = initialBoardStr ? initialBoardStr.split(",") : [];
      gameState.targetWord = body.dataset.initialTarget || "";
      gameState.score = parseInt(body.dataset.initialScore, 10) || 0;

      // Timer (unchanged)
      const startTime = Date.now();
      setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const m = String(Math.floor(elapsed / 60)).padStart(2, "0");
        const s = String(elapsed % 60).padStart(2, "0");
        timerDisplay.textContent = `${m}:${s}`;
      }, 1000);

      // Start the render loop!
      gameLoop();
    }
    
    // --- 8. Start the Game ---
    init();

  </script>
</body>
</html>